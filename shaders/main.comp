#version 450

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (std140, set = 0, binding = 0) uniform uniformParameters {
    uint frameIndex;
    float fov;
    vec3 cameraPosition;
    vec3 cameraForward;
    vec3 cameraRight;
    vec3 cameraUp;
};

layout (set = 0, binding = 1, rgba32f) uniform image2D resultImage;

/////////// Constants ///////////
#define MAX_SPHERES 10
#define MAX_RAY_BOUNCES 5
#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define EPSILON 1e-4

/////////// Structs ///////////
struct Ray {
    vec3 ori;
    vec3 dir;
};

struct Material {
    vec3 emissionColor;
    float emissionStrength;
    vec3 color;
};

struct Sphere {
    vec3 pos;
    float rad;
    Material mat;
};

struct Scene {
    Sphere spheres[MAX_SPHERES];
    uint count;
};

struct HitInfo {
    bool didCollide;
    float dst;
    vec3 hitPoint;
    vec3 normal;
    Material mat;
};

/////////// Helpers ///////////
uint WangHash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

float RandomFloat01(inout uint state) {
    state = WangHash(state);
    return float(state & 0x00FFFFFFu) / float(0x01000000u);
}

vec3 RandomInSemiSphere(vec3 normal, inout uint state) {
    vec3 randomDir = normalize(vec3(
                               RandomFloat01(state) * 2.0 - 1.0,
                               RandomFloat01(state) * 2.0 - 1.0,
                               RandomFloat01(state) * 2.0 - 1.0
                               ));

    return dot(randomDir, normal) > 0.0 ? randomDir : -randomDir;
}

void StorePixel(ivec2 coord, vec3 color) {
    vec3 prev = imageLoad(resultImage, coord).rgb;

    vec3 updated = (prev * float(frameIndex - 1) + color) / float(frameIndex);

    imageStore(resultImage, coord, vec4(updated, 1.0));
}

/////////// Core ///////////
HitInfo RaySphereIntersection(Ray ray, const Sphere sphere)
{
    HitInfo hitInfo;
    hitInfo.didCollide = false;

    vec3 offsetRayOrigin = ray.ori - sphere.pos;
    float a = dot(ray.dir, ray.dir);
    float b = 2.0 * dot(offsetRayOrigin, ray.dir);
    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphere.rad * sphere.rad;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant >= 0.0) {
        float dst = (-b - sqrt(discriminant)) / (2.0 * a);
        if (dst >= 0.0) {
            hitInfo.didCollide = true;
            hitInfo.dst = dst;
            hitInfo.hitPoint = ray.ori + dst * ray.dir;
            hitInfo.normal = normalize(hitInfo.hitPoint - sphere.pos);
            hitInfo.mat = sphere.mat;
        }
    }
    return hitInfo;
}

Ray GenerateRay(ivec2 pixelCoord) {
    ivec2 size = imageSize(resultImage);
    vec2 uv = (vec2(pixelCoord) + 0.5) / size;
    vec2 screen = uv * 2.0 - 1.0;
    screen.x *= size.x / size.y;

    float focalLength = 1.0 / tan(fov * 0.5);
    vec3 rayDir = normalize(
        screen.x * cameraRight +
        screen.y * cameraUp +
        focalLength * cameraForward
    );

    Ray ray;
    ray.ori = cameraPosition;
    ray.dir = rayDir;
    return ray;
}

HitInfo ClosestHit(Ray ray, const Scene scene) {
    HitInfo closest;
    closest.didCollide = false;
    closest.dst = FLT_MAX;

    for (int j = 0; j < scene.count; j++) {
        HitInfo current = RaySphereIntersection(ray, scene.spheres[j]);
        if (current.didCollide && current.dst < closest.dst) closest = current;
    }

    return closest;
}

vec3 AmbientLight(Ray ray) {
    vec3 dir = normalize(ray.dir);

    float t = 0.5 * (dir.y + 1.0);

    vec3 horizonColor = vec3(1.0);
    vec3 skyColor = vec3(0.5, 0.7, 1.0);

    return mix(horizonColor, skyColor, t);
}

vec3 Trace(Ray ray, const Scene scene, inout uint state) {
    vec3 incomingLight = vec3(0.0);
    vec3 rayColor = vec3(1.0);

    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {
        HitInfo hitInfo = ClosestHit(ray, scene);

        if (hitInfo.didCollide) {
            ray.ori = hitInfo.hitPoint + hitInfo.normal * EPSILON;
            ray.dir = RandomInSemiSphere(hitInfo.normal, state);

            incomingLight += hitInfo.mat.emissionColor * rayColor * hitInfo.mat.emissionStrength;
            rayColor *= hitInfo.mat.color;
        } else {
            incomingLight += AmbientLight(ray) * rayColor;
            break;
        }
    }

    return incomingLight;
}

/////////// Scene ///////////
Scene CreateScene() {
    Scene scene;

    scene.count = 3u;

    scene.spheres[0] = Sphere(vec3(0.0, 0.0, -5.0), 1.0, Material(vec3(0.0), 0.0, vec3(1.0, 0.0, 0.0))); // Red
    scene.spheres[1] = Sphere(vec3(9.0, -40.0, -8.0), 30.0, Material(vec3(1.0, 1.0, 0.7), 5.0, vec3(0.0))); // Sun
    scene.spheres[2] = Sphere(vec3(0.0, 52.0, -6.0), 50.0, Material(vec3(1.0), 0.0, vec3(0.2))); // Grey (floor)

    return scene;
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(resultImage);
    if (coord.x >= size.x || coord.y >= size.y) {
        return;
    }

    Ray ray = GenerateRay(coord);
    Scene scene = CreateScene();
    uint seed = coord.y * size.x + coord.x + frameIndex * 41848451;

    vec3 color = Trace(ray, scene, seed);

    StorePixel(coord, color);
}
