#version 460

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/////////// Constants ///////////
#define BVH_STACK_SIZE 32
#define MAX_RAY_BOUNCES 5
#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define EPSILON 1e-4
#define AA_RATIO 1e-3

/////////// Structs ///////////
struct Ray {
    vec3 ori;
    vec3 dir;
};

struct Material {
    vec3 color;
    float smoothness;
    vec3 emissionColor;
    float emissionStrength;
};

struct Sphere {
    vec3 pos;
    float rad;
    Material mat;
};

struct Triangle {
    vec3 a, b, c;
};

struct BoundingBox {
    vec3 min, max;
};

struct Mesh {
    uint start;
    Material mat;
};

struct BVH_Node {
    BoundingBox bbox;

    uint left;
    uint right;

    uint start;
    uint count;
};

struct HitInfo {
    bool didCollide;
    float dst;
    vec3 hitPoint;
    vec3 normal;
    Material mat;
};

/////////// Uniforms ///////////
layout (push_constant) uniform PushData {
    uint frameIndex;
};

layout (set = 0, binding = 0, rgba32f) uniform image2D resultImage;

layout (set = 0, binding = 1, std140) uniform CameraData {
    vec3 cameraPosition;
    vec3 cameraForward;
    vec3 cameraRight;
    vec3 cameraUp;
    float fov;
};

layout (set = 0, binding = 2, std140) uniform SceneData {
    uint numTriangles;
    uint numSpheres;
    uint numMeshes;
};

layout (set = 0, binding = 3, std430) buffer Meshes {
    Mesh meshes[];
};

layout (set = 0, binding = 4, std430) buffer Triangles {
    Triangle triangles[];
};

layout (set = 0, binding = 5, std430) buffer BVH_Nodes {
    BVH_Node nodes[];
};

layout (set = 0, binding = 6, std430) buffer Spheres {
    Sphere spheres[];
};

/////////// Helpers ///////////
uint WangHash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

float RandomFloat01(inout uint state) {
    state = WangHash(state);
    return float(state & 0x00FFFFFFu) / float(0x01000000u);
}

vec3 RandomVec3(inout uint state) {
    return normalize(vec3(
                     RandomFloat01(state) * 2.0 - 1.0,
                     RandomFloat01(state) * 2.0 - 1.0,
                     RandomFloat01(state) * 2.0 - 1.0
                     ));
}

vec3 RandomInSemiSphere(vec3 normal, inout uint state) {
    vec3 randomDir = RandomVec3(state);
    return dot(randomDir, normal) > 0.0 ? randomDir : -randomDir;
}

void StorePixel(ivec2 coord, vec3 color) {
    vec3 prev = imageLoad(resultImage, coord).rgb;

    vec3 updated = (prev * float(frameIndex - 1) + color) / float(frameIndex);

    imageStore(resultImage, coord, vec4(updated, 1.0));
}

/////////// Core ///////////
HitInfo RaySphereIntersection(Ray ray, const Sphere sphere) {
    HitInfo hitInfo;
    hitInfo.didCollide = false;

    vec3 offsetRayOrigin = ray.ori - sphere.pos;
    float a = dot(ray.dir, ray.dir);
    float b = 2.0 * dot(offsetRayOrigin, ray.dir);
    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphere.rad * sphere.rad;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant >= 0.0) {
        float dst = (-b - sqrt(discriminant)) / (2.0 * a);
        if (dst >= 0.0) {
            hitInfo.didCollide = true;
            hitInfo.dst = dst;
            hitInfo.hitPoint = ray.ori + dst * ray.dir;
            hitInfo.normal = normalize(hitInfo.hitPoint - sphere.pos);
            hitInfo.mat = sphere.mat;
        }
    }
    return hitInfo;
}

HitInfo RayTriangleIntersection(Ray ray, const Triangle triangle) {
    vec3 ab = triangle.b - triangle.a;
    vec3 ac = triangle.c - triangle.a;
    vec3 normal = cross(ab, ac);
    vec3 ao = ray.ori - triangle.a;
    vec3 dao = cross(ao, ray.dir);

    float determinant = -dot(ray.dir, normal);
    float invDet = 1 / determinant;

    float dst = dot(ao, normal) * invDet;
    float u = dot(ac, dao) * invDet;
    float v = -dot(ab, dao) * invDet;
    float w = 1 - u - v;

    HitInfo hitInfo;
    hitInfo.didCollide = determinant >= 1E-6 && dst >= 0 && u >= 0 && v >= 0 && w >= 0;
    hitInfo.hitPoint = ray.ori + ray.dir * dst;
    hitInfo.normal = normalize(normal);
    hitInfo.dst = dst;
    return hitInfo;
}

// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d
bool RayBoundingBoxIntersection(Ray ray, const vec3 boxMin, const vec3 boxMax) {
    vec3 tMin = (boxMin - ray.ori) / ray.dir;
    vec3 tMax = (boxMax - ray.ori) / ray.dir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    return tNear <= tFar;
}

HitInfo RayBVHIntersection(Ray ray, Material mat, uint startIndex) {
    HitInfo closest;
    closest.didCollide = false;
    closest.dst = FLT_MAX;
    closest.mat = mat;

    uint stack[BVH_STACK_SIZE];
    uint stackTopIndex = 0;
    stack[stackTopIndex++] = startIndex;

    while (stackTopIndex != 0) {
        BVH_Node currentNode = nodes[stack[--stackTopIndex]];

        if (currentNode.left == 0 && currentNode.right == 0) {
            for (uint t = currentNode.start; t < currentNode.start + currentNode.count; t++) {
                HitInfo current = RayTriangleIntersection(ray, triangles[t]);
                if (current.didCollide && current.dst < closest.dst) {
                    closest = current;
                }
            }
        } else if (RayBoundingBoxIntersection(ray, currentNode.bbox.min, currentNode.bbox.max)) {
            stack[stackTopIndex++] = currentNode.left;
            stack[stackTopIndex++] = currentNode.right;
        }
    }
    return closest;
};

Ray GenerateRay(ivec2 pixelCoord, inout uint state) {
    ivec2 size = imageSize(resultImage);
    vec2 uv = (vec2(pixelCoord) + 0.5) / size;
    vec2 screen = uv * 2.0 - 1.0;
    screen.x *= size.x / size.y;

    float focalLength = 1.0 / tan(fov * 0.5);
    vec3 rayDir = normalize(screen.x * cameraRight + screen.y * cameraUp + focalLength * cameraForward);

    // Anti-aliasing
    rayDir.xyz += RandomVec3(state) * AA_RATIO;

    return Ray(cameraPosition, rayDir);
}

HitInfo ClosestHit(Ray ray) {
    HitInfo closest;
    closest.didCollide = false;
    closest.dst = FLT_MAX;

    // Spheres
    for (int j = 0; j < numSpheres; j++) {
        HitInfo current = RaySphereIntersection(ray, spheres[j]);
        if (current.didCollide && current.dst < closest.dst) closest = current;
    }

    // Single BVH Mesh
    for (int i = 0; i < numMeshes; i++) {
        const Mesh m = meshes[i];
        HitInfo current = RayBVHIntersection(ray, m.mat, m.start);
        if (current.didCollide && current.dst < closest.dst) closest = current;
    }

    return closest;
}

vec3 AmbientLight(Ray ray) {
    vec3 dir = normalize(ray.dir);

    float t = 0.5 * (dir.y + 1.0);

    vec3 horizonColor = vec3(1.0);
    vec3 skyColor = vec3(0.5, 0.7, 1.0);

    return mix(horizonColor, skyColor, t);
}

vec3 Trace(Ray ray, inout uint state) {
    vec3 incomingLight = vec3(0.0);
    vec3 rayColor = vec3(1.0);

    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {
        HitInfo hitInfo = ClosestHit(ray);

        if (hitInfo.didCollide) {
            ray.ori = hitInfo.hitPoint + hitInfo.normal * EPSILON;
            vec3 diffuseDir = normalize(hitInfo.normal + RandomInSemiSphere(hitInfo.normal, state));
            vec3 specularDir = reflect(ray.dir, hitInfo.normal);
            ray.dir = mix(diffuseDir, specularDir, hitInfo.mat.smoothness);

            incomingLight += hitInfo.mat.emissionColor * rayColor * hitInfo.mat.emissionStrength;
            rayColor *= hitInfo.mat.color;
        } else {
            incomingLight += AmbientLight(ray) * rayColor;
            break;
        }
    }

    return incomingLight;
}


void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(resultImage);
    if (coord.x >= size.x || coord.y >= size.y) return;

    uint seed = coord.y * size.x + coord.x + frameIndex * 41848451;

    Ray ray = GenerateRay(coord, seed);
    vec3 color = Trace(ray, seed);

    StorePixel(coord, color);
}
