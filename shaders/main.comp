#version 460

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/////////// Constants ///////////
#define MAX_SPHERES 20
#define MAX_VERTICES 10
#define MAX_FACES 10
#define MAX_MESHES 5
#define MAX_RAY_BOUNCES 5
#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define EPSILON 1e-4
#define AA_RATIO 1e-3

/////////// Structs ///////////
struct Ray {
    vec3 ori;
    vec3 dir;
};

struct Material {
    vec3 color;
    float smoothness;
    vec3 emissionColor;
    float emissionStrength;
};

struct Sphere {
    vec3 pos;
    float rad;
    Material mat;
};

struct Mesh {
    uint start;
    uint count;
    Material material;
    mat4 transform;
};

struct Scene {
    Sphere spheres[MAX_SPHERES];

    vec3 vertices[MAX_VERTICES];
    uvec3 faces[MAX_FACES];
    Mesh meshes[MAX_MESHES];

    uint sphereCount;
    uint verticesCount;
    uint meshCount;
    uint facesCount;
};

struct HitInfo {
    bool didCollide;
    float dst;
    vec3 hitPoint;
    vec3 normal;
    Material mat;
};

/////////// Uniforms ///////////
layout (push_constant) uniform PushData {
    uint frameIndex;
};

layout (std140, set = 0, binding = 0) uniform CameraBuffer {
    vec3 cameraPosition;
    vec3 cameraForward;
    vec3 cameraRight;
    vec3 cameraUp;
    float fov;
};

layout (set = 0, binding = 1, rgba32f) uniform image2D resultImage;

layout (std140, set = 0, binding = 2) uniform SceneBuffer {
    Scene scene;
};

/////////// Helpers ///////////
uint WangHash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

float RandomFloat01(inout uint state) {
    state = WangHash(state);
    return float(state & 0x00FFFFFFu) / float(0x01000000u);
}

vec3 RandomVec3(inout uint state) {
    return normalize(vec3(
                     RandomFloat01(state) * 2.0 - 1.0,
                     RandomFloat01(state) * 2.0 - 1.0,
                     RandomFloat01(state) * 2.0 - 1.0
                     ));
}

vec3 RandomInSemiSphere(vec3 normal, inout uint state) {
    vec3 randomDir = RandomVec3(state);
    return dot(randomDir, normal) > 0.0 ? randomDir : -randomDir;
}

void StorePixel(ivec2 coord, vec3 color) {
    vec3 prev = imageLoad(resultImage, coord).rgb;

    vec3 updated = (prev * float(frameIndex - 1) + color) / float(frameIndex);

    imageStore(resultImage, coord, vec4(updated, 1.0));
}

/////////// Core ///////////
HitInfo RaySphereIntersection(Ray ray, const Sphere sphere) {
    HitInfo hitInfo;
    hitInfo.didCollide = false;

    vec3 offsetRayOrigin = ray.ori - sphere.pos;
    float a = dot(ray.dir, ray.dir);
    float b = 2.0 * dot(offsetRayOrigin, ray.dir);
    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphere.rad * sphere.rad;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant >= 0.0) {
        float dst = (-b - sqrt(discriminant)) / (2.0 * a);
        if (dst >= 0.0) {
            hitInfo.didCollide = true;
            hitInfo.dst = dst;
            hitInfo.hitPoint = ray.ori + dst * ray.dir;
            hitInfo.normal = normalize(hitInfo.hitPoint - sphere.pos);
            hitInfo.mat = sphere.mat;
        }
    }
    return hitInfo;
}

// Möller–Trumbore intersection algorithm
HitInfo RayTriangleIntersection(Ray ray, const uvec3 face, const mat4 transform) {
    HitInfo hitInfo;
    hitInfo.didCollide = false;

    vec3 a = (transform * vec4(scene.vertices[face.x], 1.0)).rgb;
    vec3 b = (transform * vec4(scene.vertices[face.y], 1.0)).rgb;
    vec3 c = (transform * vec4(scene.vertices[face.z], 1.0)).rgb;

    vec3 ab = b - a;
    vec3 ac = c - a;

    vec3 pvec = cross(ray.dir, ac);
    float det = dot(ab, pvec);

    if (abs(det) < 1e-6)
    return hitInfo;

    float invDet = 1.0 / det;
    vec3 tvec = ray.ori - a;

    float u = dot(tvec, pvec) * invDet;
    if (u < 0.0 || u > 1.0)
    return hitInfo;

    vec3 qvec = cross(tvec, ab);
    float v = dot(ray.dir, qvec) * invDet;
    if (v < 0.0 || u + v > 1.0)
    return hitInfo;

    float t = dot(ac, qvec) * invDet;
    if (t < 0.0)
    return hitInfo;

    hitInfo.didCollide = true;
    hitInfo.hitPoint = ray.ori + ray.dir * t;
    hitInfo.normal = normalize(cross(ab, ac));
    hitInfo.dst = t;
    return hitInfo;
}


Ray GenerateRay(ivec2 pixelCoord, inout uint state) {
    ivec2 size = imageSize(resultImage);
    vec2 uv = (vec2(pixelCoord) + 0.5) / size;
    vec2 screen = uv * 2.0 - 1.0;
    screen.x *= size.x / size.y;

    float focalLength = 1.0 / tan(fov * 0.5);
    vec3 rayDir = normalize(screen.x * cameraRight + screen.y * cameraUp + focalLength * cameraForward);

    // Anti-aliasing
    rayDir.xyz += RandomVec3(state) * AA_RATIO;

    return Ray(cameraPosition, rayDir);
}

HitInfo ClosestHit(Ray ray) {
    HitInfo closest;
    closest.didCollide = false;
    closest.dst = FLT_MAX;

    // Spheres
    for (int j = 0; j < scene.sphereCount; j++) {
        HitInfo current = RaySphereIntersection(ray, scene.spheres[j]);
        if (current.didCollide && current.dst < closest.dst) closest = current;
    }

    // Meshes
    for (int i = 0; i < scene.meshCount; i++) {
        const Mesh m = scene.meshes[i];

        for (uint t = m.start; t < m.start + m.count; t++) {
            HitInfo current = RayTriangleIntersection(ray, scene.faces[t], m.transform);
            if (current.didCollide && current.dst < closest.dst) {
                closest = current;
                closest.mat = m.material;
                break;
            }
        }
    }


    return closest;
}

vec3 AmbientLight(Ray ray) {
    vec3 dir = normalize(ray.dir);

    float t = 0.5 * (dir.y + 1.0);

    vec3 horizonColor = vec3(1.0);
    vec3 skyColor = vec3(0.5, 0.7, 1.0);

    return mix(horizonColor, skyColor, t);
}

vec3 Trace(Ray ray, inout uint state) {
    vec3 incomingLight = vec3(0.0);
    vec3 rayColor = vec3(1.0);

    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {
        HitInfo hitInfo = ClosestHit(ray);

        if (hitInfo.didCollide) {
            ray.ori = hitInfo.hitPoint + hitInfo.normal * EPSILON;
            vec3 diffuseDir = normalize(hitInfo.normal + RandomInSemiSphere(hitInfo.normal, state));
            vec3 specularDir = reflect(ray.dir, hitInfo.normal);
            ray.dir = mix(diffuseDir, specularDir, hitInfo.mat.smoothness);

            incomingLight += hitInfo.mat.emissionColor * rayColor * hitInfo.mat.emissionStrength;
            rayColor *= hitInfo.mat.color;
        } else {
            incomingLight += AmbientLight(ray) * rayColor;
            break;
        }
    }

    return incomingLight;
}


void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(resultImage);
    if (coord.x >= size.x || coord.y >= size.y) return;

    uint seed = coord.y * size.x + coord.x + frameIndex * 41848451;

    Ray ray = GenerateRay(coord, seed);
    vec3 color = Trace(ray, seed);

    StorePixel(coord, color);
}
